// Code generated by github.com/zdandoh/ecs DO NOT EDIT.

package {{ .Pkg }}

{{ .CompImport }}
import "fmt"
import "reflect"
import "slices"
import "sync"

var sortLock sync.Mutex

func SelectSorted(cmp func(a Entity, b Entity) int, selector interface{}) {
    sortLock.Lock()
    defer sortLock.Unlock()

    i := 0
    switch selector.(type) {
    {{ range .Selects }}{{if not .EarlyStop}}
    case func(Entity, {{ range .Args }}*{{ cpkg .Comp }}{{ .Name }}, {{ end }}):
        Select(func(e Entity, {{ range $i, $arg := .Args }}arg{{ $i }} *{{ cpkg .Comp }}{{ $arg.Name }}, {{ end }}) {
            sortSpace[i] = e
            i++
        })
    {{ end }}{{ end }}
    default:
        panic(fmt.Sprintf("unknown selector function: run go generate: %s", reflect.TypeOf(selector).String()))
    }

    slices.SortStableFunc(sortSpace[:i], cmp)
    for j := 0; j < i; j++ {
        entity := sortSpace[j]
        switch fun := selector.(type) {
        {{ range .Selects }}{{if not .EarlyStop}}
        case func(Entity, {{ range .Args }}*{{ cpkg .Comp }}{{ .Name }}, {{ end }}):
            fun(entity, {{ range .Args }}&store{{ .Name }}[entity.id() >> entityPageBits][entity.id() % entityPageSize], {{ end }})
        {{ end }}{{ end }}
        }
    }
}

// Select accepts a selector function of the form func(e Entity, c *component.$Name, ...) and calls the function for
// each entity that has the matching component set. The component pointers passed to the selector function
// can be manipulated directly within the callback, and are valid for the lifetime of the entity. Component pointers
// should not be stored outside the ECS.
// Select can also match up to one relationship. To match relationships, pass a selector function of the form
// func(e Entity, target Entity, r *component.$RelationshipName, c *component.$Name, ...).
// The selector will be called for relationship attached to entity e with target entity e, along with any matching
// component data that e has.
func Select(selector interface{}) {
    cont := true
    _ = cont

    var entity Entity
    switch fun := selector.(type) {
    {{ $containerCount := .CompContainerCount }}
    {{ range .Selects }}
    {{ $sel := . }}
    case func(Entity, {{ range .Args }}{{ if .Relationship }}Entity,{{ end }} *comp.{{ .Name }}, {{ end }}) {{ if .EarlyStop }}bool{{ end }}:
        {{ range $i := makerange $containerCount }}
        const matchID{{ $i }} = {{ range $sel.Args }}{{ $mapindex := compmapindex .CompIndex }}{{ if eq $mapindex $i }}{{ compsubindex .CompIndex }} |{{ end }}{{ end }} 0
        {{ end }}

        for pageNo, page := range entities {
            {{ range .Args }}
            found{{ .Name }} := uint16(0)
            max{{ .Name }} := pageHeaders[pageNo][{{ .CompIndex }}]
            {{ end }}
            for _, entity = range page {
                if {{ range .Args}}found{{ .Name }} >= max{{ .Name }} ||{{ end }} false {
                    break
                }
                {{ range .Args }}
                found{{ .Name }} += uint16((entity.components[{{ compmapindex .CompIndex }}] >> {{ .CompIndex }}) & 1)
                {{ end }}

                if {{ range $i := makerange $containerCount }}matchID{{ $i }} & entity.components[{{ $i }}] == matchID{{ $i }} &&{{ end }} true {
                    {{ $rel := .Relationship }}
                    {{ if .Relationship }}
                    entity.Each{{ .Relationship.Name }}(func(target Entity, {{ if $rel.HasData }}data *comp.{{ .Relationship.Name }}{{ end }}) {
                        fun(entity, {{ range .Args }}{{ if .Relationship }}target, {{ if $rel.HasData }}data{{ else }}nil{{ end }}{{ else }}&store{{ .Name }}[entity.id() >> entityPageBits][entity.id() % entityPageSize]{{ end }}, {{ end }})
                    })
                    {{ else }}
                    {{ if .EarlyStop }}cont = {{ end }}fun(entity, {{ range .Args }}&store{{ .Name }}[entity.id() >> entityPageBits][entity.id() % entityPageSize], {{ end }})
                    {{ if .EarlyStop }}if !cont { return }{{ end }}
                    {{ end }}
                }
            }

        }
    {{ end }}
    case func(Entity):
        for _, page := range entities {
            for _, entity := range page {
                fun(entity)
            }
        }
    default:
        panic(fmt.Sprintf("unknown selector function: run go generate: %s", reflect.TypeOf(selector).String()))
    }
}