package {{ .Pkg }}

{{ .CompImport }}
import "{{ .FullPkg }}/entity"
import "unsafe"

var currEntities = 0
var entityCap = 0

var systems []System

func init() {
    newEntityPage()
}

var sortSpace []Entity

func newEntityPage() {
    newPage := make([]Entity, entityPageSize)
    entities = append(entities, newPage)

    pageHeaders = append(pageHeaders, pageHeader{})
    sortSpace = make([]Entity, entityCap + entityPageSize)

    {{ range .Comps }}
    new{{ .Name }}Page := make([]comp.{{ .Name }}, entityPageSize)
    store{{ .Name }} = append(store{{ .Name }}, new{{ .Name }}Page)
    {{ end }}
    entityCap += entityPageSize
}

func Reset() {
    entities = nil
    freeList = nil
    pageHeaders = nil
    {{ range .Comps }}
    store{{ .Name }} = nil
    {{ end }}
    currEntities = 0
    entityCap = 0

    newEntityPage()
}

func NewEntity() Entity {
    var retID EntityID
    if len(freeList) == 0 {
        if currEntities >= entityCap {
            newEntityPage()
        }

        retID = EntityID(currEntities)
        currEntities++
    } else {
        retID = freeList[len(freeList)-1]
        freeList = freeList[:len(freeList)-1]
    }

	entities[retID >> entityPageBits][retID % entityPageSize] = Entity{
	    id: retID,
	    generation: entities[retID >> entityPageBits][retID % entityPageSize].generation + 1}

	return entities[retID >> entityPageBits][retID % entityPageSize]
}

func Lookup(r entity.Ref) Entity {
    return *(*Entity)(unsafe.Pointer(&r))
}

func (e Entity) Is(other Entity) bool {
    return e.id == other.id && e.generation == other.generation
}

func (e Entity) Zero() bool {
    return e.id == 0 && e.generation == 0
}

func (e Entity) Ref() entity.Ref {
    return *(*entity.Ref)(unsafe.Pointer(&e))
}

func EntityCount() int {
    return currEntities
}