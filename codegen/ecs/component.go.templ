// Code generated by github.com/zdandoh/ecs DO NOT EDIT.

package {{ .Pkg }}

{{ .CompImport }}
{{ if .RelCount }}
import "slices"
{{ end }}

type ComponentID [{{ .CompContainerCount }}]uint64

{{ range .Relationships }}
type rel{{ .Name }}Entry struct {
    ident uint64
    data comp.{{ .Name }}
}

type rel{{ .Name }} struct {
    deletes int
    rels []rel{{ .Name }}Entry
}
{{ end }}

{{ range .Comps }}
var store{{ .Name }} [][]{{ cpkg . }}{{ .Name }}{{ end }}

{{ range $i, $comp := .Comps }}
var {{ $comp.Name }}ID = ComponentID{}
{{ end }}

func init() {
    {{ range $i, $comp := .Comps }}
    {{ $comp.Name }}ID[{{ compmapindex $i }}] = {{ compsubindex $i }}{{ end }}
}

{{ range $i, $c := .Comps }}
func (e Entity) {{ cprefix $c }}Set{{ .Name }}(c {{ cpkg . }}{{ .Name }}) {
    if !e.Alive() {
        return
    }

    if entities[e.id() >> entityPageBits][e.id() % entityPageSize].components[{{ compmapindex $i }}] & {{ compsubindex $i }} == 0 {
        pageHeaders[e.id() >> entityPageBits][{{ $i }}]++
    }
    entities[e.id() >> entityPageBits][e.id() % entityPageSize].components[{{ compmapindex $i }}] |= {{ compsubindex $i }}
    store{{ .Name }}[e.id() >> entityPageBits][e.id() % entityPageSize] = c
}
{{ end }}

{{ range $i, $c := .Comps }}
func (e Entity) {{ cprefix $c }}Remove{{ .Name }}() {
    if !e.Alive() {
        return
    }

    if entities[e.id() >> entityPageBits][e.id() % entityPageSize].components[{{ compmapindex $i }}] & {{ compsubindex $i }} != 0 {
        pageHeaders[e.id() >> entityPageBits][{{ $i }}]--
    }
    entities[e.id() >> entityPageBits][e.id() % entityPageSize].components[{{ compmapindex $i }}] &= ^uint64({{ compsubindex $i }})
    // Zero any pointers to allow the GC to free memory
    var zero {{ cpkg $c }}{{ .Name }}
    store{{ .Name }}[e.id() >> entityPageBits][e.id() % entityPageSize] = zero
}
{{ end }}

{{ range $i, $c := .Comps }}
func (e Entity) {{ cprefix $c }}Has{{ .Name }}() bool {
    if !e.Alive() {
        return false
    }
    return entities[e.id() >> entityPageBits][e.id() % entityPageSize].components[{{ compmapindex $i }}] & {{ compsubindex $i }} != 0
}
{{ end }}

{{ range .Relationships }}
func (e Entity) Each{{ .Name }}(each func(e Entity, {{ if .HasData }}data *comp.{{ .Name }}{{ end }})) {
    rel := e._{{ .Name }}()

    if rel != nil {
        cleanup := false
        for i, entry := range rel.rels {
            ent := entities[(entry.ident >> 32) >> entityPageBits][(entry.ident >> 32) % entityPageSize]
            if ent.generation() != (entry.ident & 0x00000000FFFFFFFF) {
                rel.rels[i].ident = 0
                cleanup = true
                continue
            }

            origSlice := rel.rels
            each(ent, {{ if .HasData }}&rel.rels[i].data{{ end }})
            // Copy any mutations made with the passed pointer if the slice changes
            if cap(origSlice) != cap(rel.rels) && origSlice[i].ident == rel.rels[i].ident {
                rel.rels[i] = origSlice[i]
            }
        }

        if cleanup {
            rel.rels = slices.DeleteFunc(rel.rels, func(ent rel{{ .Name }}Entry) bool {
                return ent.ident == 0
            })
        }
        rel.deletes = 0
        if len(rel.rels) == 0 {
            e._Remove{{ .Name }}()
        }
    }
}

func (e Entity) Set{{ .Name }}(target Entity, {{ if .HasData }}data comp.{{ .Name }}{{ end }}) {
    if !target.Alive() || !e.Alive() {
        return
    }
    rel := e._{{ .Name }}()
    if rel == nil {
        e._Set{{ .Name }}(rel{{ .Name}}{rels: nil})
        rel = e._{{ .Name }}()
    }

    newEnt := rel{{ .Name }}Entry{ident: target.ident, {{ if .HasData }}data: data{{ end }}}
    index, found := slices.BinarySearchFunc(rel.rels, newEnt, func(a, b rel{{ .Name }}Entry) int {
        return int(a.ident >> 32) - int(b.ident >> 32)
    })
    if found {
        return
    }

    rel.rels = slices.Insert(rel.rels, index, newEnt)
}

func (e Entity) {{ .Name }}(target Entity) {{ if .HasData }}*comp.{{ .Name }}{{ else }}bool{{ end }} {
    if !target.Alive() || !e.Alive() {
        return {{ if .HasData }}nil{{ else }}false{{ end }}
    }

    rel := e._{{ .Name }}()
    if rel == nil {
        return {{ if .HasData }}nil{{ else }}false{{ end }}
    }

    {{ if .HasData }}index{{ else }}_{{ end }}, found := slices.BinarySearchFunc(rel.rels, rel{{ .Name }}Entry{ident: target.ident}, func(a, b rel{{ .Name }}Entry) int {
        return int(a.ident >> 32) - int(b.ident >> 32)
    })
    if !found {
        return {{ if .HasData }}nil{{ else }}false{{ end }}
    }
    return {{ if .HasData }}&rel.rels[index].data{{ else }}true{{ end }}
}

func (e Entity) Remove{{ .Name }}(target Entity) {
    if !target.Alive() || !e.Alive() {
        return
    }

    rel := e._{{ .Name }}()
    if rel == nil {
        return
    }

    index, found := slices.BinarySearchFunc(rel.rels, rel{{ .Name }}Entry{ident: target.ident}, func(a, b rel{{ .Name }}Entry) int {
        return int(a.ident >> 32) - int(b.ident >> 32)
    })
    if !found {
        return
    }
    // Only mark for deletion, don't modify slice
    rel.rels[index].ident = 0
    rel.deletes++

    if len(rel.rels) == 0 || len(rel.rels) == rel.deletes {
        e._Remove{{ .Name }}()
    }
}

func (e Entity) Any{{ .Name }}() bool {
    return e._Has{{ .Name }}()
}
{{ end }}