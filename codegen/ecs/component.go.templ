// Code generated by github.com/zdandoh/ecs DO NOT EDIT.

package {{ .Pkg }}

{{ .CompImport }}
{{ if .RelCount }}
import "slices"
{{ end }}

type ComponentID [{{ .CompContainerCount }}]uint64

{{ range .Relationships }}
type rel{{ .Name }}Entry struct {
    ident uint64
    data comp.{{ .Name }}
}

type rel{{ .Name }} struct {
    deletes int
    rels []rel{{ .Name }}Entry
}
{{ end }}

{{ range .Comps }}
var store{{ .Name }} [][]{{ cpkg . }}{{ .Name }}{{ end }}

{{ range $i, $comp := .Comps }}
// {{ $comp.Name }}ID is a unique identifier for the {{ .Name }} component.
var {{ $comp.Name }}ID = ComponentID{}
{{ end }}

func init() {
    {{ range $i, $comp := .Comps }}
    {{ $comp.Name }}ID[{{ compmapindex $i }}] = {{ compsubindex $i }}{{ end }}
}

{{ range $i, $c := .Comps }}
// Set{{ .Name }} sets the {{ .Name }} component to the provided value for an entity.
func (e Entity) {{ cprefix $c }}Set{{ .Name }}(c {{ cpkg . }}{{ .Name }}) {
    if !e.Alive() {
        return
    }

    if entities[e.id() >> entityPageBits][e.id() % entityPageSize].components[{{ compmapindex $i }}] & {{ compsubindex $i }} == 0 {
        pageHeaders[e.id() >> entityPageBits][{{ $i }}]++
    }
    entities[e.id() >> entityPageBits][e.id() % entityPageSize].components[{{ compmapindex $i }}] |= {{ compsubindex $i }}
    store{{ .Name }}[e.id() >> entityPageBits][e.id() % entityPageSize] = c
}
{{ end }}

{{ range $i, $c := .Comps }}
// Remove{{ .Name }} removes the {{ .Name }} component from the entity.
func (e Entity) {{ cprefix $c }}Remove{{ .Name }}() {
    if !e.Alive() {
        return
    }

    if entities[e.id() >> entityPageBits][e.id() % entityPageSize].components[{{ compmapindex $i }}] & {{ compsubindex $i }} != 0 {
        pageHeaders[e.id() >> entityPageBits][{{ $i }}]--
    }
    entities[e.id() >> entityPageBits][e.id() % entityPageSize].components[{{ compmapindex $i }}] &= ^uint64({{ compsubindex $i }})
    // Zero any pointers to allow the GC to free memory
    var zero {{ cpkg $c }}{{ .Name }}
    store{{ .Name }}[e.id() >> entityPageBits][e.id() % entityPageSize] = zero
}
{{ end }}

{{ range $i, $c := .Comps }}
// Has{{ .Name }} returns true if the given entity has {{ .Name }} set.
func (e Entity) {{ cprefix $c }}Has{{ .Name }}() bool {
    if !e.Alive() {
        return false
    }
    return entities[e.id() >> entityPageBits][e.id() % entityPageSize].components[{{ compmapindex $i }}] & {{ compsubindex $i }} != 0
}
{{ end }}

{{ range .Relationships }}
// Each{{ .Name }} calls the provided callback for each {{ .Name }} relationship associated with the entity.
// It automatically prunes entities that have died since the last call to Each{{ .Name }}. It returns true
// if any dead entities are removed during iteration.
func (e Entity) Each{{ .Name }}(each func(e Entity, {{ if .HasData }}data *comp.{{ .Name }}{{ end }})) bool {
    rel := e._{{ .Name }}()

    if rel == nil {
        return false
    }

    cleanup := false
    for i, entry := range rel.rels {
        ent := entities[(entry.ident >> 32) >> entityPageBits][(entry.ident >> 32) % entityPageSize]
        if ent.generation() != (entry.ident & 0x00000000FFFFFFFF) {
            rel.rels[i].ident = 0
            cleanup = true
            continue
        }

        origSlice := rel.rels
        each(ent, {{ if .HasData }}&rel.rels[i].data{{ end }})
        // Copy any mutations made with the passed pointer if the slice changes
        if cap(origSlice) != cap(rel.rels) && len(rel.rels) > i && origSlice[i].ident == rel.rels[i].ident {
            rel.rels[i] = origSlice[i]
        }
    }

    if cleanup {
        rel.rels = slices.DeleteFunc(rel.rels, func(ent rel{{ .Name }}Entry) bool {
            return ent.ident == 0
        })
    }
    rel.deletes = 0
    if len(rel.rels) == 0 {
        e._Remove{{ .Name }}()
    }

    return cleanup
}

// Set{{ .Name }} associates the given target entity with the entity. If the component contains data
// that should be associated with the relationship, that data is stored alongside the association,
// replacing any data that previously existed. Set{{ .Name }} returns true if a new relationship is created.
func (e Entity) Set{{ .Name }}(target Entity, {{ if .HasData }}data comp.{{ .Name }}{{ end }}) bool {
    if !target.Alive() || !e.Alive() {
        return false
    }
    rel := e._{{ .Name }}()
    if rel == nil {
        e._Set{{ .Name }}(rel{{ .Name}}{rels: nil})
        rel = e._{{ .Name }}()
    }

    newEnt := rel{{ .Name }}Entry{ident: target.ident, {{ if .HasData }}data: data{{ end }}}
    index, found := slices.BinarySearchFunc(rel.rels, newEnt, func(a, b rel{{ .Name }}Entry) int {
        return int(a.ident >> 32) - int(b.ident >> 32)
    })
    if found {
        rel.rels[index] = newEnt
        return false
    }

    rel.rels = slices.Insert(rel.rels, index, newEnt)
    return true
}

// {{ .Name }} returns true if a {{ .Name }} relationship exists with the given entity. If the relationship
// has associated data, a pointer to that data is returned. The pointer is invalidated by any subsequent modifications
// to the {{ .Name }} relationship of the entity.
func (e Entity) {{ .Name }}(target Entity) {{ if .HasData }}*comp.{{ .Name }}{{ else }}bool{{ end }} {
    if !target.Alive() || !e.Alive() {
        return {{ if .HasData }}nil{{ else }}false{{ end }}
    }

    rel := e._{{ .Name }}()
    if rel == nil {
        return {{ if .HasData }}nil{{ else }}false{{ end }}
    }

    {{ if .HasData }}index{{ else }}_{{ end }}, found := slices.BinarySearchFunc(rel.rels, rel{{ .Name }}Entry{ident: target.ident}, func(a, b rel{{ .Name }}Entry) int {
        return int(a.ident >> 32) - int(b.ident >> 32)
    })
    if !found {
        return {{ if .HasData }}nil{{ else }}false{{ end }}
    }
    return {{ if .HasData }}&rel.rels[index].data{{ else }}true{{ end }}
}

// Remove{{ .Name }} removes the {{ .Name }} association between the two entities. If a relationship was removed,
// Remove{{ .Name }} returns true.
func (e Entity) Remove{{ .Name }}(target Entity) bool {
    if !target.Alive() || !e.Alive() {
        return false
    }

    rel := e._{{ .Name }}()
    if rel == nil {
        return false
    }

    index, found := slices.BinarySearchFunc(rel.rels, rel{{ .Name }}Entry{ident: target.ident}, func(a, b rel{{ .Name }}Entry) int {
        return int(a.ident >> 32) - int(b.ident >> 32)
    })
    if !found {
        return false
    }
    // Only mark for deletion, don't modify slice
    rel.rels[index].ident = 0
    rel.deletes++

    if len(rel.rels) == 0 || len(rel.rels) == rel.deletes {
        e._Remove{{ .Name }}()
    }

    return true
}

// Any{{ .Name }} returns true if the entity has any instances of the {{ .Name }} relationship.
func (e Entity) Any{{ .Name }}() bool {
    return e._Has{{ .Name }}()
}
{{ end }}