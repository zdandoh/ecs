// Code generated by github.com/zdandoh/ecs DO NOT EDIT.

package {{ .Pkg }}

{{ .CompImport }}
import "math/bits"

const entityPageBits = 10
const entityPageSize = 1 << entityPageBits

type EntityID uint64

type ComponentMapping [{{ .CompContainerCount }}]uint64

type Entity struct {
    ident uint64
	components ComponentMapping
}

type pageHeader [{{ .CompCount }}]uint16

var freeList []EntityID
var pageHeaders []pageHeader
var entities [][]Entity

// Kill makes the entity eligible for reuse and prevents any subsequent modifications to
// the entity.
func (e Entity) Kill() {
    if !e.Alive() {
        return
    }

    for _, compPart := range entities[e.id() >> entityPageBits][e.id() % entityPageSize].components {
        end := 64 - bits.LeadingZeros64(compPart)
        start := bits.TrailingZeros64(compPart)
        for i := start; i < end; i++ {
            pageHeaders[e.id()>>entityPageBits][i] -= uint16((compPart >> i) & 1)
        }
    }

	freeList = append(freeList, e.ID())
	entities[e.id() >> entityPageBits][e.id() % entityPageSize].ident++
	entities[e.id() >> entityPageBits][e.id() % entityPageSize].components = ComponentMapping{}
}

// Alive returns true if the given entity is alive.
func (e Entity) Alive() bool {
    return e.generation() == entities[e.id() >> entityPageBits][e.id() % entityPageSize].generation()
}

// ID returns the unique identifier of the entity.
func (e Entity) ID() EntityID {
    return EntityID(e.id())
}

func (e Entity) id() uint64 {
    return e.ident >> 32
}

func (e Entity) generation() uint64 {
    return e.ident & 0x00000000FFFFFFFF
}

{{ range $i, $c := .Comps }}
// {{ $c.Name }} returns a pointer to the {{ .Name }} component. This pointer is only valid for the
// lifetime of the entity. Component pointers should not be stored outside the ECS.
func (e Entity) {{ cprefix $c }}{{ $c.Name }}() *{{ cpkg $c }}{{ $c.Name }} {
    if !e.Alive() {
        return nil
    }
    if entities[e.id() >> entityPageBits][e.id() % entityPageSize].components[{{ compmapindex $i }}] & {{ compsubindex $i }} != 0 {
        return &store{{ $c.Name }}[e.id() >> entityPageBits][e.id() % entityPageSize]
    }
    return nil
}
{{ end }}

{{ range $i, $c := .Comps }}
// {{ .Name }}Default sets the {{ .Name }} component to the provided value if it is not already set.
func (e Entity) {{ cprefix $c }}Default{{ $c.Name }}(def {{ cpkg $c }}{{ $c.Name }}) *{{ cpkg $c }}{{ $c.Name }} {
    if !e.{{ cprefix $c }}Has{{ $c.Name }}() {
        e.{{ cprefix $c }}Set{{ $c.Name }}(def)
    }

    return &store{{ $c.Name }}[e.id() >> entityPageBits][e.id() % entityPageSize]
}
{{ end }}

// Components returns all components on an entity, but it isn't fast - don't use for non-debug purposes!
func (e Entity) Components() []interface{} {
    comps := make([]interface{}, 0)
    {{ range .Comps }}
    if e.{{ cprefix . }}Has{{ .Name }}() {
        comps = append(comps, *e.{{ cprefix . }}{{ .Name }}())
    }
    {{ end}}
    return comps
}